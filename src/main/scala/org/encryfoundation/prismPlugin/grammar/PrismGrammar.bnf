{
  parserClass="org.encryfoundation.prismPlugin.GeneratedParser"

  implements = "org.encryfoundation.prismPlugin.psi.PrismCompositeElement"
  extends="org.encryfoundation.prismPlugin.psi.PrismCompositeElementImpl"

  psiClassPrefix="Prism"
  psiImplClassSuffix="Impl"
  psiPackage="org.encryfoundation.prismPlugin.psi"
  psiImplPackage="org.encryfoundation.prismPlugin.impl"

  elementTypeHolderClass="org.encryfoundation.prismPlugin.psi.PrismTypes"
  elementTypeClass="org.encryfoundation.prismPlugin.psi.PrismCompositeElementType"
  tokenTypeClass="org.encryfoundation.prismPlugin.psi.PrismTokenType"

  psiImplUtilClass="org.encryfoundation.prismPlugin.psi.PrismPsiUtilImpl"

  tokens = [

        //bool types
        BOOLEAN_TRUE = 'true'
        BOOLEAN_FALSE = 'false'

        //compr
        LT = '<'
        GT = '>'
        EQ = '=='
        GtE = '>='
        LtE = '<='
        NotEq = '<>'

        //bool and, or

        AND = '&&'
        OR = '||'

        //math
        ADD = '+'
        SUB = '-'
        POW = '**'
        MULT = '*'
        DIV = "/"
        MOD = '%'

        //type
        ANY_TYPE = 'Any'
        UNIT_TYPE = 'Unit'
        BOOL_TYPE = 'Bool'
        INT_TYPE = 'Int'
        BYTE_TYPE = 'Byte'
        STRING_TYPE = 'Sting'


        LEFT_CURLY_BRACKET = '{'
        RIGHT_CURLY_BRACKET = '}'

        LEFT_ROUND_BRACKET = '('
        RIGHT_ROUND_BRACKET = ')'

        EQU = '='

        COLON = ':'

        DOUBLE_QUOTES = '"'
        SINGLE_QUOTE = "'"

        LAMB = 'lamb'
        LET = 'let'

        IF = 'if'
        ELSE = 'else'

        CONTRACT_INIT = 'contract'

        NUMBER = 'regexp:[0-9]+'
        STRING = 'regexp:["][a-zA-Z0-9_]*["]'
        BASE_STRING = "regexp:['][a-zA-Z0-9_]*[']"
        IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'

        WHITE_SPACE = 'regexp:\s+'
    ]

    implements("VariableDefinition|FunctionDefinition|ReferencedIdentifier")="org.encryfoundation.prismPlugin.psi.PrismNamedElement"
    extends("VariableDefinition|FunctionDefinition|ReferencedIdentifier")="org.encryfoundation.prismPlugin.psi.PrismNamedElementImpl"
}


SimpleFile ::= Contract

BooleanType ::= BOOLEAN_TRUE | BOOLEAN_FALSE

MathOp ::= ADD | SUB | POW | MULT | DIV | MOD

ComprOp ::= AND | OR | GtE | LtE | NotEq | GT | LT | EQ

BASE58_STR ::= base58init BASE_STRING

BASE16_STR ::= base16init BASE_STRING

private base58init ::= base58

private base16init ::= base16

FunctionDefinition ::= def IDENTIFIER LEFT_ROUND_BRACKET ArgsList? RIGHT_ROUND_BRACKET (COLON Type)? EQU LEFT_CURLY_BRACKET (Expr | FunctionDefinition | VariableDefinition)* RIGHT_CURLY_BRACKET {
    methods = [getNameIdentifier]
}

ReferencedIdentifier ::= IDENTIFIER {
    methods = [getReference getNameIdentifier]
}

STMT ::= BASE58_STR | BASE16_STR | NUMBER | STRING | BooleanType | ReferencedIdentifier

VariableDefinition ::= LET IDENTIFIER (COLON Type)? EQU Expr {
    methods = [getNameIdentifier]
}

Type ::= ANY_TYPE | UNIT_TYPE | BOOL_TYPE | INT_TYPE | BYTE_TYPE | STRING_TYPE // add collections

private argIdentifier ::= IDENTIFIER

ArgsList ::= argIdentifier (COLON Type)? (',' ArgsList)?

//exprs

//arithm

    RightArithExpr ::= MathOp (NUMBER | ReferencedIdentifier) (RightArithExpr)?

    ArithExpr ::= (NUMBER | ReferencedIdentifier) RightArithExpr

//compr

    //RightBoolExpr ::= ComprOp (BooleanType | FuncCallExpr| IDENTIFIER | STMT) (RightBoolExpr)?

    //BoolExpr ::= (BooleanType | FuncCallExpr | IDENTIFIER | STMT) RightBoolExpr?

    Comparison ::= ArithExpr (ComprOp ArithExpr)+

    NotTest ::= (NOT NotTest) | Comparison

    AndTest ::= NotTest (AND NotTest)+

    BoolExpr ::= AndTest (OR AndTest)+

//lamb def

    LambExpr ::= LAMB LEFT_ROUND_BRACKET ArgsList RIGHT_ROUND_BRACKET EQU Expr

// if expr

    IfExpr ::= IF LEFT_ROUND_BRACKET BoolExpr RIGHT_ROUND_BRACKET LEFT_CURLY_BRACKET Expr? RIGHT_CURLY_BRACKET
               ELSE LEFT_CURLY_BRACKET Expr? RIGHT_CURLY_BRACKET

// if let expr

    IfLetExpr ::= IF LEFT_ROUND_BRACKET VariableDefinition RIGHT_ROUND_BRACKET LEFT_CURLY_BRACKET Expr? RIGHT_CURLY_BRACKET
                  ELSE LEFT_CURLY_BRACKET Expr? RIGHT_CURLY_BRACKET

// func call

    FuncCallExpr ::= ReferencedIdentifier LEFT_ROUND_BRACKET identifiers_list?  RIGHT_ROUND_BRACKET {
        methods = [getReference getFuncIdentifier]
    }

    identifiers_list ::= Expr ("," identifiers_list)?

// global expr

    Expr ::= ArithExpr
    | BoolExpr
    | LambExpr
    | FuncCallExpr
    | IfExpr
    | IfLetExpr
    | STMT


//Contract

    Contract ::= CONTRACT_INIT LEFT_ROUND_BRACKET ArgsList? RIGHT_ROUND_BRACKET EQU LEFT_CURLY_BRACKET (Expr | FunctionDefinition | VariableDefinition)* RIGHT_CURLY_BRACKET